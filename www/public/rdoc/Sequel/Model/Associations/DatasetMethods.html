<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>module Sequel::Model::Associations::DatasetMethods - Sequel: The Database Toolkit for Ruby</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
  var index_rel_prefix = "../../../";
</script>

<script src="../../../js/navigation.js" defer></script>
<script src="../../../js/search.js" defer></script>
<script src="../../../js/search_index.js" defer></script>
<script src="../../../js/searcher.js" defer></script>
<script src="../../../js/darkfish.js" defer></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link href="../../../css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="module">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li class="calls-super" ><a href="#method-i-as_hash">#as_hash</a>
    
    <li ><a href="#method-i-association_join">#association_join</a>
    
    <li class="calls-super" ><a href="#method-i-complex_expression_sql_append">#complex_expression_sql_append</a>
    
    <li ><a href="#method-i-eager">#eager</a>
    
    <li ><a href="#method-i-eager_graph">#eager_graph</a>
    
    <li ><a href="#method-i-eager_graph_association">#eager_graph_association</a>
    
    <li ><a href="#method-i-eager_graph_associations">#eager_graph_associations</a>
    
    <li ><a href="#method-i-eager_graph_build_associations">#eager_graph_build_associations</a>
    
    <li ><a href="#method-i-eager_graph_with_options">#eager_graph_with_options</a>
    
    <li class="calls-super" ><a href="#method-i-to_hash_groups">#to_hash_groups</a>
    
    <li class="calls-super" ><a href="#method-i-ungraphed">#ungraphed</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="module-Sequel::Model::Associations::DatasetMethods">
  <h1 id="module-Sequel::Model::Associations::DatasetMethods" class="module">
    module Sequel::Model::Associations::DatasetMethods
  </h1>

  <section class="description">
    
<p>Eager loading makes it so that you can load all associated records for a set of objects in a single query, instead of a separate query for each object.</p>

<p>Two separate implementations are provided.  <code>eager</code> should be used most of the time, as it loads associated records using one query per association.  However, it does not allow you the ability to filter or order based on columns in associated tables.  <code>eager_graph</code> loads all records in a single query using JOINs, allowing you to filter or order based on columns in associated tables.  However, <code>eager_graph</code> is usually slower than <code>eager</code>, especially if multiple one_to_many or many_to_many associations are joined.</p>

<p>You can cascade the eager loading (loading associations on associated objects) with no limit to the depth of the cascades.  You do this by passing a hash to <code>eager</code> or <code>eager_graph</code> with the keys being associations of the current model and values being associations of the model associated with the current model via the key.</p>

<p>The arguments can be symbols or hashes with symbol keys (for cascaded eager loading). Examples:</p>

<pre class="ruby"><span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>, <span class="ruby-value">:genre</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:artist</span>, <span class="ruby-value">:genre</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">eager</span>(<span class="ruby-value">:genre</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:genre</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> <span class="ruby-value">:tracks</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">albums:</span> <span class="ruby-value">:tracks</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-value">:genre</span>}).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-value">:genre</span>}).<span class="ruby-identifier">all</span>
</pre>

<p>You can also pass a callback as a hash value in order to customize the dataset being eager loaded at query time, analogous to the way the :eager_block association option allows you to customize it at association definition time. For example, if you wanted artists with their albums since 1990:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">year</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1990</span>}})
</pre>

<p>Or if you needed albums and their artist&#39;s name only, using a single query:</p>

<pre class="ruby"><span class="ruby-constant">Albums</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">artist:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">select</span>(<span class="ruby-value">:name</span>)})
</pre>

<p>To cascade eager loading while using a callback, you substitute the cascaded associations with a single entry hash that has the proc callback as the key and  the cascaded associations as the value.  This will load artists with their albums since 1990, and also the tracks on those albums and the genre for those tracks:</p>

<pre class="ruby"><span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> {<span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">year</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1990</span>}}<span class="ruby-operator">=&gt;</span>{<span class="ruby-value">tracks:</span> <span class="ruby-value">:genre</span>}})
</pre>

  </section>

  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-as_hash" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">as_hash</span><span
            class="method-args">(key_column=nil, value_column=nil, opts=OPTS)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>If the dataset is being eagerly loaded, default to calling all instead of each.</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              
            </div>
          

          
          <div class="method-source-code" id="as_hash-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">3287</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">as_hash</span>(<span class="ruby-identifier">key_column</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">value_column</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)
<span class="line-num">3288</span>   <span class="ruby-keyword">if</span> (<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:eager_graph</span>] <span class="ruby-operator">||</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:eager</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">opts</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-value">:all</span>)
<span class="line-num">3289</span>     <span class="ruby-identifier">opts</span> = <span class="ruby-constant">Hash</span>[<span class="ruby-identifier">opts</span>]
<span class="line-num">3290</span>     <span class="ruby-identifier">opts</span>[<span class="ruby-value">:all</span>] = <span class="ruby-keyword">true</span>
<span class="line-num">3291</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3292</span>   <span class="ruby-keyword">super</span>
<span class="line-num">3293</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-association_join" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">association_join</span><span
            class="method-args">(*associations)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Adds one or more INNER JOINs to the existing dataset using the keys and conditions specified by the given association(s).  Take the same arguments as <a href="DatasetMethods.html#method-i-eager_graph"><code>eager_graph</code></a>, and operates similarly, but only adds the joins as opposed to making the other changes (such as adding selected columns and setting up eager loading).</p>

<p>The following methods also exist for specifying a different type of JOIN:</p>
<dl class="rdoc-list note-list"><dt>association_full_join 
<dd>
<p>FULL JOIN</p>
</dd><dt>association_inner_join 
<dd>
<p>INNER JOIN</p>
</dd><dt>association_left_join 
<dd>
<p>LEFT JOIN</p>
</dd><dt>association_right_join 
<dd>
<p>RIGHT JOIN</p>
</dd></dl>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-comment"># For each album, association_join load the artist</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">association_join</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM albums</span>
<span class="ruby-comment"># INNER JOIN artists AS artist ON (artists.id = albums.artist_id)</span>

<span class="ruby-comment"># For each album, association_join load the artist, using a specified alias</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">association_join</span>(<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:artist</span>].<span class="ruby-identifier">as</span>(<span class="ruby-value">:a</span>)).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM albums</span>
<span class="ruby-comment"># INNER JOIN artists AS a ON (a.id = albums.artist_id)</span>

<span class="ruby-comment"># For each album, association_join load the artist and genre</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">association_join</span>(<span class="ruby-value">:artist</span>, <span class="ruby-value">:genre</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">association_join</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">association_join</span>(<span class="ruby-value">:genre</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM albums</span>
<span class="ruby-comment"># INNER JOIN artists AS artist ON (artist.id = albums.artist_id)</span>
<span class="ruby-comment"># INNER JOIN genres AS genre ON (genre.id = albums.genre_id)</span>

<span class="ruby-comment"># For each artist, association_join load albums and tracks for each album</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">association_join</span>(<span class="ruby-value">albums:</span> <span class="ruby-value">:tracks</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># INNER JOIN albums ON (albums.artist_id = artists.id)</span>
<span class="ruby-comment"># INNER JOIN tracks ON (tracks.album_id = albums.id)</span>

<span class="ruby-comment"># For each artist, association_join load albums, tracks for each album, and genre for each track</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">association_join</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-value">:genre</span>}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># INNER JOIN albums ON (albums.artist_id = artists.id)</span>
<span class="ruby-comment"># INNER JOIN tracks ON (tracks.album_id = albums.id)</span>
<span class="ruby-comment"># INNER JOIN genres AS genre ON (genre.id = tracks.genre_id)</span>

<span class="ruby-comment"># For each artist, association_join load albums with year &gt; 1990</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">association_join</span>(<span class="ruby-value">albums:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">year</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1990</span>}}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># INNER JOIN (</span>
<span class="ruby-comment">#   SELECT * FROM albums WHERE (year &gt; 1990)</span>
<span class="ruby-comment"># ) AS albums ON (albums.artist_id = artists.id)</span>

<span class="ruby-comment"># For each artist, association_join load albums and tracks 1-10 for each album</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">association_join</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">number:</span> <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>)}}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># INNER JOIN albums ON (albums.artist_id = artists.id)</span>
<span class="ruby-comment"># INNER JOIN (</span>
<span class="ruby-comment">#   SELECT * FROM tracks WHERE ((number &gt;= 1) AND (number &lt;= 10))</span>
<span class="ruby-comment"># ) AS tracks ON (tracks.albums_id = albums.id)</span>

<span class="ruby-comment"># For each artist, association_join load albums with year &gt; 1990, and tracks for those albums</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">association_join</span>(<span class="ruby-value">albums:</span> {<span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">year</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1990</span>}}<span class="ruby-operator">=&gt;</span><span class="ruby-value">:tracks</span>}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT *</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># INNER JOIN (</span>
<span class="ruby-comment">#   SELECT * FROM albums WHERE (year &gt; 1990)</span>
<span class="ruby-comment"># ) AS albums ON (albums.artist_id = artists.id)</span>
<span class="ruby-comment"># INNER JOIN tracks ON (tracks.album_id = albums.id)</span>
</pre>
          
          

          
          <div class="method-source-code" id="association_join-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">2993</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">association_join</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">associations</span>)
<span class="line-num">2994</span>   <span class="ruby-identifier">association_inner_join</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">associations</span>)
<span class="line-num">2995</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-complex_expression_sql_append" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">complex_expression_sql_append</span><span
            class="method-args">(sql, op, args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>If the expression is in the form <code>x = y</code> where <code>y</code> is a <code>Sequel::Model</code> instance, array of <code>Sequel::Model</code> instances, or a <code>Sequel::Model</code> dataset, assume <code>x</code> is an association symbol and look up the association reflection via the dataset&#39;s model.  From there, return the appropriate <a href="../../SQL.html"><code>SQL</code></a> based on the type of association and the values of the foreign/primary keys of <code>y</code>.  For most association types, this is a simple transformation, but for <code>many_to_many</code> associations this  creates a subquery to the join table.</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              
            </div>
          

          
          <div class="method-source-code" id="complex_expression_sql_append-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">3004</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">complex_expression_sql_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">op</span>, <span class="ruby-identifier">args</span>)
<span class="line-num">3005</span>   <span class="ruby-identifier">r</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">1</span>]
<span class="line-num">3006</span>   <span class="ruby-keyword">if</span> (((<span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> <span class="ruby-value">:&#39;=&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> <span class="ruby-value">:&#39;!=&#39;</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>)) <span class="ruby-operator">||</span>
<span class="line-num">3007</span>       (<span class="ruby-identifier">multiple</span> = ((<span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> <span class="ruby-value">:IN</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">op</span> <span class="ruby-operator">==</span> <span class="ruby-value">:&#39;NOT IN&#39;</span>) <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">is_ds</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Dataset</span>)) <span class="ruby-operator">||</span> (<span class="ruby-identifier">r</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:all?</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">all?</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>)})))))
<span class="line-num">3008</span>     <span class="ruby-identifier">l</span> = <span class="ruby-identifier">args</span>[<span class="ruby-value">0</span>]
<span class="line-num">3009</span>     <span class="ruby-keyword">if</span> <span class="ruby-identifier">ar</span> = <span class="ruby-identifier">model</span>.<span class="ruby-identifier">association_reflections</span>[<span class="ruby-identifier">l</span>]
<span class="line-num">3010</span>       <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;filtering by associations is not allowed for #{ar.inspect}&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">ar</span>[<span class="ruby-value">:allow_filtering_by</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">false</span>
<span class="line-num">3011</span> 
<span class="line-num">3012</span>       <span class="ruby-keyword">if</span> <span class="ruby-identifier">multiple</span>
<span class="line-num">3013</span>         <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">ar</span>.<span class="ruby-identifier">associated_class</span>
<span class="line-num">3014</span>         <span class="ruby-keyword">if</span> <span class="ruby-identifier">is_ds</span>
<span class="line-num">3015</span>           <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:model</span>)
<span class="line-num">3016</span>             <span class="ruby-keyword">unless</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">model</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">klass</span>
<span class="line-num">3017</span>               <span class="ruby-comment"># A dataset for a different model class, could be a valid regular query</span>
<span class="line-num">3018</span>               <span class="ruby-keyword">return</span> <span class="ruby-keyword">super</span>
<span class="line-num">3019</span>             <span class="ruby-keyword">end</span>
<span class="line-num">3020</span>           <span class="ruby-keyword">else</span>
<span class="line-num">3021</span>             <span class="ruby-comment"># Not a model dataset, could be a valid regular query</span>
<span class="line-num">3022</span>             <span class="ruby-keyword">return</span> <span class="ruby-keyword">super</span>
<span class="line-num">3023</span>           <span class="ruby-keyword">end</span>
<span class="line-num">3024</span>         <span class="ruby-keyword">else</span>
<span class="line-num">3025</span>           <span class="ruby-keyword">unless</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">all?</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-identifier">klass</span>)}
<span class="line-num">3026</span>             <span class="ruby-identifier">raise</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;invalid association class for one object for association #{l.inspect} used in dataset filter for model #{model.inspect}, expected class #{klass.inspect}&quot;</span>
<span class="line-num">3027</span>           <span class="ruby-keyword">end</span>
<span class="line-num">3028</span>         <span class="ruby-keyword">end</span>
<span class="line-num">3029</span>       <span class="ruby-keyword">elsif</span> <span class="ruby-operator">!</span><span class="ruby-identifier">r</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-identifier">ar</span>.<span class="ruby-identifier">associated_class</span>)
<span class="line-num">3030</span>         <span class="ruby-identifier">raise</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;invalid association class #{r.class.inspect} for association #{l.inspect} used in dataset filter for model #{model.inspect}, expected class #{ar.associated_class.inspect}&quot;</span>
<span class="line-num">3031</span>       <span class="ruby-keyword">end</span>
<span class="line-num">3032</span> 
<span class="line-num">3033</span>       <span class="ruby-keyword">if</span> <span class="ruby-identifier">exp</span> = <span class="ruby-identifier">association_filter_expression</span>(<span class="ruby-identifier">op</span>, <span class="ruby-identifier">ar</span>, <span class="ruby-identifier">r</span>)
<span class="line-num">3034</span>         <span class="ruby-identifier">literal_append</span>(<span class="ruby-identifier">sql</span>, <span class="ruby-identifier">exp</span>)
<span class="line-num">3035</span>       <span class="ruby-keyword">else</span>
<span class="line-num">3036</span>         <span class="ruby-identifier">raise</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;invalid association type #{ar[:type].inspect} for association #{l.inspect} used in dataset filter for model #{model.inspect}&quot;</span>
<span class="line-num">3037</span>       <span class="ruby-keyword">end</span>
<span class="line-num">3038</span>     <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">multiple</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">is_ds</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">empty?</span>)
<span class="line-num">3039</span>       <span class="ruby-comment"># Not a query designed for this support, could be a valid regular query</span>
<span class="line-num">3040</span>       <span class="ruby-keyword">super</span>
<span class="line-num">3041</span>     <span class="ruby-keyword">else</span>
<span class="line-num">3042</span>       <span class="ruby-identifier">raise</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;invalid association #{l.inspect} used in dataset filter for model #{model.inspect}&quot;</span>
<span class="line-num">3043</span>     <span class="ruby-keyword">end</span>
<span class="line-num">3044</span>   <span class="ruby-keyword">else</span>
<span class="line-num">3045</span>     <span class="ruby-keyword">super</span>
<span class="line-num">3046</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3047</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eager" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">eager</span><span
            class="method-args">(*associations)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The preferred eager loading method.  Loads all associated records using one query for each association.</p>

<p>The basic idea for how it works is that the dataset is first loaded normally. Then it goes through all associations that have been specified via <code>eager</code>. It loads each of those associations separately, then associates them back to the original dataset via primary/foreign keys.  Due to the necessity of all objects being present, you need to use <code>all</code> to use eager loading, as it can&#39;t work with <code>each</code>.</p>

<p>This implementation avoids the complexity of extracting an object graph out of a single dataset, by building the object graph out of multiple datasets, one for each association.  By using a separate dataset for each association, it avoids problems such as aliasing conflicts and creating cartesian product result sets if multiple one_to_many or many_to_many eager associations are requested.</p>

<p>One limitation of using this method is that you cannot filter the current dataset based on values of columns in an associated table, since the associations are loaded in separate queries.  To do that you need to load all associations in the same query, and extract an object graph from the results of that query. If you need to filter based on columns in associated tables, look at <code>eager_graph</code> or join the tables you need to filter on manually. </p>

<p>Each association&#39;s order, if defined, is respected. If the association uses a block or has an :eager_block argument, it is used.</p>

<p>To modify the associated dataset that will be used for the eager load, you should use a hash for the association, with the key being the association name symbol, and the value being a callable object that is called with the associated dataset and should return a modified dataset.  If that association also has dependent associations, instead of a callable object, use a hash with the callable object being the key, and the dependent association(s) as the value.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-comment"># For each album, eager load the artist</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM albums</span>
<span class="ruby-comment"># SELECT * FROM artists WHERE (id IN (...))</span>

<span class="ruby-comment"># For each album, eager load the artist and genre</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>, <span class="ruby-value">:genre</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">eager</span>(<span class="ruby-value">:genre</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM albums</span>
<span class="ruby-comment"># SELECT * FROM artists WHERE (id IN (...))</span>
<span class="ruby-comment"># SELECT * FROM genres WHERE (id IN (...))</span>

<span class="ruby-comment"># For each artist, eager load albums and tracks for each album</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> <span class="ruby-value">:tracks</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM artists</span>
<span class="ruby-comment"># SELECT * FROM albums WHERE (artist_id IN (...))</span>
<span class="ruby-comment"># SELECT * FROM tracks WHERE (album_id IN (...))</span>

<span class="ruby-comment"># For each artist, eager load albums, tracks for each album, and genre for each track</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-value">:genre</span>}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM artists</span>
<span class="ruby-comment"># SELECT * FROM albums WHERE (artist_id IN (...))</span>
<span class="ruby-comment"># SELECT * FROM tracks WHERE (album_id IN (...))</span>
<span class="ruby-comment"># SELECT * FROM genre WHERE (id IN (...))</span>

<span class="ruby-comment"># For each artist, eager load albums with year &gt; 1990</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">year</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1990</span>}}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM artists</span>
<span class="ruby-comment"># SELECT * FROM albums WHERE ((year &gt; 1990) AND (artist_id IN (...)))</span>

<span class="ruby-comment"># For each artist, eager load albums and tracks 1-10 for each album</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">number:</span> <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>)}}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM artists</span>
<span class="ruby-comment"># SELECT * FROM albums WHERE (artist_id IN (...))</span>
<span class="ruby-comment"># SELECT * FROM tracks WHERE ((number &gt;= 1) AND (number &lt;= 10) AND (album_id IN (...)))</span>

<span class="ruby-comment"># For each artist, eager load albums with year &gt; 1990, and tracks for those albums</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager</span>(<span class="ruby-value">albums:</span> {<span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">year</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1990</span>}}<span class="ruby-operator">=&gt;</span><span class="ruby-value">:tracks</span>}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT * FROM artists</span>
<span class="ruby-comment"># SELECT * FROM albums WHERE ((year &gt; 1990) AND (artist_id IN (...)))</span>
<span class="ruby-comment"># SELECT * FROM albums WHERE (artist_id IN (...))</span>
</pre>
          
          

          
          <div class="method-source-code" id="eager-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">3124</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eager</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">associations</span>)
<span class="line-num">3125</span>   <span class="ruby-identifier">opts</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:eager</span>]
<span class="line-num">3126</span>   <span class="ruby-identifier">association_opts</span> = <span class="ruby-identifier">eager_options_for_associations</span>(<span class="ruby-identifier">associations</span>)
<span class="line-num">3127</span>   <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">opts</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">association_opts</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">association_opts</span>
<span class="line-num">3128</span>   <span class="ruby-identifier">clone</span>(<span class="ruby-value">:eager</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">opts</span>.<span class="ruby-identifier">freeze</span>)
<span class="line-num">3129</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eager_graph" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">eager_graph</span><span
            class="method-args">(*associations)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The secondary eager loading method.  Loads all associations in a single query. This method should only be used if you need to filter or order based on columns in associated tables, or if you have done comparative benchmarking and determined it is faster.</p>

<p>This method uses <code>Dataset#graph</code> to create appropriate aliases for columns in all the tables.  Then it uses the graph&#39;s metadata to build the associations from the single hash, and finally replaces the array of hashes with an array model objects inside all.</p>

<p>Be very careful when using this with multiple one_to_many or many_to_many associations, as you can create large cartesian products.  If you must graph multiple one_to_many and many_to_many associations, make sure your filters are narrow if the datasets are large.</p>

<p>Each association&#39;s order, if defined, is respected. <code>eager_graph</code> probably won&#39;t work correctly on a limited dataset, unless you are only graphing many_to_one, one_to_one, and one_through_one associations.</p>

<p>Does not use the block defined for the association, since it does a single query for all objects.  You can use the :graph_* association options to modify the <a href="../../SQL.html"><code>SQL</code></a> query.</p>

<p>Like <code>eager</code>, you need to call <code>all</code> on the dataset for the eager loading to work.  If you just call <code>each</code>, it will yield plain hashes, each containing all columns from all the tables.</p>

<p>To modify the associated dataset that will be joined to the current dataset, you should use a hash for the association, with the key being the association name symbol, and the value being a callable object that is called with the associated dataset and should return a modified dataset.  If that association also has dependent associations, instead of a callable object, use a hash with the callable object being the key, and the dependent association(s) as the value.</p>

<p>You can specify an custom alias and/or join type on a per-association basis by providing an <a href="../../SQL/AliasedExpression.html"><code>Sequel::SQL::AliasedExpression</code></a> object instead of an a Symbol for the association name.</p>

<p>You cannot mix calls to <code>eager_graph</code> and <code>graph</code> on the same dataset.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-comment"># For each album, eager_graph load the artist</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT ...</span>
<span class="ruby-comment"># FROM albums</span>
<span class="ruby-comment"># LEFT OUTER JOIN artists AS artist ON (artists.id = albums.artist_id)</span>

<span class="ruby-comment"># For each album, eager_graph load the artist, using a specified alias</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:artist</span>].<span class="ruby-identifier">as</span>(<span class="ruby-value">:a</span>)).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT ...</span>
<span class="ruby-comment"># FROM albums</span>
<span class="ruby-comment"># LEFT OUTER JOIN artists AS a ON (a.id = albums.artist_id)</span>

<span class="ruby-comment"># For each album, eager_graph load the artist, using a specified alias</span>
<span class="ruby-comment"># and custom join type</span>

<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-constant">Sequel</span>[<span class="ruby-value">:artist</span>].<span class="ruby-identifier">as</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">join_type:</span> <span class="ruby-value">:inner</span>)).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT ...</span>
<span class="ruby-comment"># FROM albums</span>
<span class="ruby-comment"># INNER JOIN artists AS a ON (a.id = albums.artist_id)</span>

<span class="ruby-comment"># For each album, eager_graph load the artist and genre</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:artist</span>, <span class="ruby-value">:genre</span>).<span class="ruby-identifier">all</span>
<span class="ruby-constant">Album</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:artist</span>).<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">:genre</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT ...</span>
<span class="ruby-comment"># FROM albums</span>
<span class="ruby-comment"># LEFT OUTER JOIN artists AS artist ON (artist.id = albums.artist_id)</span>
<span class="ruby-comment"># LEFT OUTER JOIN genres AS genre ON (genre.id = albums.genre_id)</span>

<span class="ruby-comment"># For each artist, eager_graph load albums and tracks for each album</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">albums:</span> <span class="ruby-value">:tracks</span>).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT ...</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN albums ON (albums.artist_id = artists.id)</span>
<span class="ruby-comment"># LEFT OUTER JOIN tracks ON (tracks.album_id = albums.id)</span>

<span class="ruby-comment"># For each artist, eager_graph load albums, tracks for each album, and genre for each track</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-value">:genre</span>}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT ...</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN albums ON (albums.artist_id = artists.id)</span>
<span class="ruby-comment"># LEFT OUTER JOIN tracks ON (tracks.album_id = albums.id)</span>
<span class="ruby-comment"># LEFT OUTER JOIN genres AS genre ON (genre.id = tracks.genre_id)</span>

<span class="ruby-comment"># For each artist, eager_graph load albums with year &gt; 1990</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">albums:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">year</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1990</span>}}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT ...</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN (</span>
<span class="ruby-comment">#   SELECT * FROM albums WHERE (year &gt; 1990)</span>
<span class="ruby-comment"># ) AS albums ON (albums.artist_id = artists.id)</span>

<span class="ruby-comment"># For each artist, eager_graph load albums and tracks 1-10 for each album</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">albums:</span> {<span class="ruby-value">tracks:</span> <span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">number:</span> <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>)}}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT ...</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN albums ON (albums.artist_id = artists.id)</span>
<span class="ruby-comment"># LEFT OUTER JOIN (</span>
<span class="ruby-comment">#   SELECT * FROM tracks WHERE ((number &gt;= 1) AND (number &lt;= 10))</span>
<span class="ruby-comment"># ) AS tracks ON (tracks.albums_id = albums.id)</span>

<span class="ruby-comment"># For each artist, eager_graph load albums with year &gt; 1990, and tracks for those albums</span>
<span class="ruby-constant">Artist</span>.<span class="ruby-identifier">eager_graph</span>(<span class="ruby-value">albums:</span> {<span class="ruby-identifier">proc</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">ds</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">where</span>{<span class="ruby-identifier">year</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1990</span>}}<span class="ruby-operator">=&gt;</span><span class="ruby-value">:tracks</span>}).<span class="ruby-identifier">all</span>
<span class="ruby-comment"># SELECT ...</span>
<span class="ruby-comment"># FROM artists</span>
<span class="ruby-comment"># LEFT OUTER JOIN (</span>
<span class="ruby-comment">#   SELECT * FROM albums WHERE (year &gt; 1990)</span>
<span class="ruby-comment"># ) AS albums ON (albums.artist_id = artists.id)</span>
<span class="ruby-comment"># LEFT OUTER JOIN tracks ON (tracks.album_id = albums.id)</span>
</pre>
          
          

          
          <div class="method-source-code" id="eager_graph-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">3234</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eager_graph</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">associations</span>)
<span class="line-num">3235</span>   <span class="ruby-identifier">eager_graph_with_options</span>(<span class="ruby-identifier">associations</span>)
<span class="line-num">3236</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eager_graph_with_options" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">eager_graph_with_options</span><span
            class="method-args">(associations, opts=OPTS)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Run <a href="DatasetMethods.html#method-i-eager_graph"><code>eager_graph</code></a> with some options specific to just this call. Unlike <a href="DatasetMethods.html#method-i-eager_graph"><code>eager_graph</code></a>, this takes the associations as a single argument instead of multiple arguments.</p>

<p>Options:</p>
<dl class="rdoc-list note-list"><dt>:join_type 
<dd>
<p>Override the join type specified in the association</p>
</dd><dt>:limit_strategy 
<dd>
<p>Use a strategy for handling limits on associations. Appropriate :limit_strategy values are:</p>
<dl class="rdoc-list note-list"><dt>true 
<dd>
<p>Pick the most appropriate based on what the database supports</p>
</dd><dt>:distinct_on 
<dd>
<p>Force use of DISTINCT ON stategy (*_one associations only)</p>
</dd><dt>:correlated_subquery 
<dd>
<p>Force use of correlated subquery strategy (one_to_* associations only)</p>
</dd><dt>:window_function 
<dd>
<p>Force use of window function strategy</p>
</dd><dt>:ruby 
<dd>
<p>Don&#39;t modify the <a href="../../SQL.html"><code>SQL</code></a>, implement limits/offsets with array slicing</p>
</dd></dl>

<p>This can also be a hash with association name symbol keys and one of the above values, to use different strategies per association.</p>

<p>The default is the :ruby strategy.  Choosing a different strategy can make your code significantly slower in some cases (perhaps even the majority of cases), so you should only use this if you have benchmarked that it is faster for your use cases.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="eager_graph_with_options-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">3258</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eager_graph_with_options</span>(<span class="ruby-identifier">associations</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)
<span class="line-num">3259</span>   <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">empty?</span>
<span class="line-num">3260</span> 
<span class="line-num">3261</span>   <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">dup</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">frozen?</span>
<span class="line-num">3262</span>   <span class="ruby-identifier">associations</span> = [<span class="ruby-identifier">associations</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
<span class="line-num">3263</span>   <span class="ruby-identifier">ds</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">eg</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:eager_graph</span>]
<span class="line-num">3264</span>     <span class="ruby-identifier">eg</span> = <span class="ruby-identifier">eg</span>.<span class="ruby-identifier">dup</span>
<span class="line-num">3265</span>     [<span class="ruby-value">:requirements</span>, <span class="ruby-value">:reflections</span>, <span class="ruby-value">:reciprocals</span>, <span class="ruby-value">:limits</span>].<span class="ruby-identifier">each</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">eg</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-identifier">eg</span>[<span class="ruby-identifier">k</span>].<span class="ruby-identifier">dup</span>}
<span class="line-num">3266</span>     <span class="ruby-identifier">eg</span>[<span class="ruby-value">:local</span>] = <span class="ruby-identifier">opts</span>
<span class="line-num">3267</span>     <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">clone</span>(<span class="ruby-value">:eager_graph</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">eg</span>)
<span class="line-num">3268</span>     <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph_associations</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>][<span class="ruby-value">:master</span>], [], <span class="ruby-operator">*</span><span class="ruby-identifier">associations</span>)
<span class="line-num">3269</span>   <span class="ruby-keyword">else</span>
<span class="line-num">3270</span>     <span class="ruby-comment"># Each of the following have a symbol key for the table alias, with the following values:</span>
<span class="line-num">3271</span>     <span class="ruby-comment"># :reciprocals :: the reciprocal value to use for this association</span>
<span class="line-num">3272</span>     <span class="ruby-comment"># :reflections :: AssociationReflection instance related to this association</span>
<span class="line-num">3273</span>     <span class="ruby-comment"># :requirements :: array of requirements for this association</span>
<span class="line-num">3274</span>     <span class="ruby-comment"># :limits :: Any limit/offset array slicing that need to be handled in ruby land after loading</span>
<span class="line-num">3275</span>     <span class="ruby-identifier">opts</span> = {<span class="ruby-value">:requirements</span><span class="ruby-operator">=&gt;</span>{}, <span class="ruby-value">:master</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">alias_symbol</span>(<span class="ruby-identifier">first_source</span>), <span class="ruby-value">:reflections</span><span class="ruby-operator">=&gt;</span>{}, <span class="ruby-value">:reciprocals</span><span class="ruby-operator">=&gt;</span>{}, <span class="ruby-value">:limits</span><span class="ruby-operator">=&gt;</span>{}, <span class="ruby-value">:local</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">opts</span>, <span class="ruby-value">:cartesian_product_number</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">0</span>, <span class="ruby-value">:row_proc</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">row_proc</span>}
<span class="line-num">3276</span>     <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">clone</span>(<span class="ruby-value">:eager_graph</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">opts</span>)
<span class="line-num">3277</span>     <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph_associations</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>][<span class="ruby-value">:master</span>], [], <span class="ruby-operator">*</span><span class="ruby-identifier">associations</span>).<span class="ruby-identifier">naked</span>
<span class="line-num">3278</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3279</span> 
<span class="line-num">3280</span>   <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>].<span class="ruby-identifier">freeze</span>
<span class="line-num">3281</span>   <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>].<span class="ruby-identifier">each_value</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">freeze</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>)}
<span class="line-num">3282</span>   <span class="ruby-identifier">ds</span>
<span class="line-num">3283</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_hash_groups" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_hash_groups</span><span
            class="method-args">(key_column, value_column=nil, opts=OPTS)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>If the dataset is being eagerly loaded, default to calling all instead of each.</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              
            </div>
          

          
          <div class="method-source-code" id="to_hash_groups-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">3297</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_hash_groups</span>(<span class="ruby-identifier">key_column</span>, <span class="ruby-identifier">value_column</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)
<span class="line-num">3298</span>   <span class="ruby-keyword">if</span> (<span class="ruby-ivar">@opts</span>[<span class="ruby-value">:eager_graph</span>] <span class="ruby-operator">||</span> <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:eager</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">opts</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-value">:all</span>)
<span class="line-num">3299</span>     <span class="ruby-identifier">opts</span> = <span class="ruby-constant">Hash</span>[<span class="ruby-identifier">opts</span>]
<span class="line-num">3300</span>     <span class="ruby-identifier">opts</span>[<span class="ruby-value">:all</span>] = <span class="ruby-keyword">true</span>
<span class="line-num">3301</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3302</span>   <span class="ruby-keyword">super</span>
<span class="line-num">3303</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ungraphed" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">ungraphed</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Do not attempt to split the result set into associations, just return results as simple objects.  This is useful if you want to use <a href="DatasetMethods.html#method-i-eager_graph"><code>eager_graph</code></a> as a shortcut to have all of the joins and aliasing set up, but want to do something else with the dataset.</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              
            </div>
          

          
          <div class="method-source-code" id="ungraphed-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">3309</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">ungraphed</span>
<span class="line-num">3310</span>   <span class="ruby-identifier">ds</span> = <span class="ruby-keyword">super</span>.<span class="ruby-identifier">clone</span>(<span class="ruby-value">:eager_graph</span><span class="ruby-operator">=&gt;</span><span class="ruby-keyword">nil</span>)
<span class="line-num">3311</span>   <span class="ruby-keyword">if</span> (<span class="ruby-identifier">eg</span> = <span class="ruby-ivar">@opts</span>[<span class="ruby-value">:eager_graph</span>]) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">rp</span> = <span class="ruby-identifier">eg</span>[<span class="ruby-value">:row_proc</span>])
<span class="line-num">3312</span>     <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">with_row_proc</span>(<span class="ruby-identifier">rp</span>)
<span class="line-num">3313</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3314</span>   <span class="ruby-identifier">ds</span>
<span class="line-num">3315</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="protected-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Protected Instance Methods</h3>
       </header>

    
      <div id="method-i-eager_graph_association" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">eager_graph_association</span><span
            class="method-args">(ds, model, ta, requirements, r, *associations)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Call graph on the association with the correct arguments, update the <a href="DatasetMethods.html#method-i-eager_graph"><code>eager_graph</code></a> data structure, and recurse into <a href="DatasetMethods.html#method-i-eager_graph_associations"><code>eager_graph_associations</code></a> if there are any passed in associations (which would be dependencies of the current association)</p>

<p>Arguments:</p>
<dl class="rdoc-list note-list"><dt>ds 
<dd>
<p>Current dataset</p>
</dd><dt>model 
<dd>
<p>Current <a href="../../Model.html"><code>Model</code></a></p>
</dd><dt>ta 
<dd>
<p>table_alias used for the parent association</p>
</dd><dt>requirements 
<dd>
<p>an array, used as a stack for requirements</p>
</dd><dt>r 
<dd>
<p>association reflection for the current association, or an <a href="../../SQL/AliasedExpression.html"><code>SQL::AliasedExpression</code></a> with the reflection as the expression, the alias base as the alias (or nil to use the default alias), and an optional hash with a :join_type entry as the columns to use a custom join type.</p>
</dd><dt>*associations 
<dd>
<p>any associations dependent on this one</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="eager_graph_association-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">3334</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eager_graph_association</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ta</span>, <span class="ruby-identifier">requirements</span>, <span class="ruby-identifier">r</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">associations</span>)
<span class="line-num">3335</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>)
<span class="line-num">3336</span>     <span class="ruby-identifier">alias_base</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">alias</span>
<span class="line-num">3337</span>     <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">columns</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>)
<span class="line-num">3338</span>       <span class="ruby-identifier">join_type</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">columns</span>[<span class="ruby-value">:join_type</span>]
<span class="line-num">3339</span>     <span class="ruby-keyword">end</span>
<span class="line-num">3340</span>     <span class="ruby-identifier">r</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">expression</span>
<span class="line-num">3341</span>   <span class="ruby-keyword">else</span>
<span class="line-num">3342</span>     <span class="ruby-identifier">alias_base</span> = <span class="ruby-identifier">r</span>[<span class="ruby-value">:graph_alias_base</span>]
<span class="line-num">3343</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3344</span>   <span class="ruby-identifier">assoc_table_alias</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">unused_table_alias</span>(<span class="ruby-identifier">alias_base</span>)
<span class="line-num">3345</span>   <span class="ruby-identifier">loader</span> = <span class="ruby-identifier">r</span>[<span class="ruby-value">:eager_grapher</span>]
<span class="line-num">3346</span>   <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">associations</span>.<span class="ruby-identifier">empty?</span>
<span class="line-num">3347</span>     <span class="ruby-keyword">if</span> <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:call</span>)
<span class="line-num">3348</span>       <span class="ruby-identifier">callback</span> = <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">first</span>
<span class="line-num">3349</span>       <span class="ruby-identifier">associations</span> = {}
<span class="line-num">3350</span>     <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">assocs</span> = <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">first</span>).<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">assocs</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">pr_assoc</span> = <span class="ruby-identifier">assocs</span>.<span class="ruby-identifier">to_a</span>.<span class="ruby-identifier">first</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">pr_assoc</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:call</span>)
<span class="line-num">3351</span>       <span class="ruby-identifier">callback</span>, <span class="ruby-identifier">assoc</span> = <span class="ruby-identifier">pr_assoc</span>
<span class="line-num">3352</span>       <span class="ruby-identifier">associations</span> = <span class="ruby-identifier">assoc</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">assoc</span> <span class="ruby-operator">:</span> [<span class="ruby-identifier">assoc</span>]
<span class="line-num">3353</span>     <span class="ruby-keyword">end</span>
<span class="line-num">3354</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3355</span>   <span class="ruby-identifier">local_opts</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>][<span class="ruby-value">:local</span>]
<span class="line-num">3356</span>   <span class="ruby-identifier">limit_strategy</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">eager_graph_limit_strategy</span>(<span class="ruby-identifier">local_opts</span>[<span class="ruby-value">:limit_strategy</span>])
<span class="line-num">3357</span> 
<span class="line-num">3358</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>[<span class="ruby-value">:conditions</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">condition_specifier?</span>(<span class="ruby-identifier">r</span>[<span class="ruby-value">:conditions</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">r</span>[<span class="ruby-value">:orig_opts</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-value">:graph_conditions</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">r</span>[<span class="ruby-value">:orig_opts</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-value">:graph_only_conditions</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">r</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-value">:graph_block</span>)
<span class="line-num">3359</span>     <span class="ruby-identifier">raise</span> <span class="ruby-constant">Error</span>, <span class="ruby-node">&quot;Cannot eager_graph association when :conditions specified and not a hash or an array of pairs.  Specify :graph_conditions, :graph_only_conditions, or :graph_block for the association.  Model: #{r[:model]}, association: #{r[:name]}&quot;</span>
<span class="line-num">3360</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3361</span> 
<span class="line-num">3362</span>   <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">loader</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:self</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">ds</span>, <span class="ruby-value">:table_alias</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">assoc_table_alias</span>, <span class="ruby-value">:implicit_qualifier</span><span class="ruby-operator">=&gt;</span>(<span class="ruby-identifier">ta</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>][<span class="ruby-value">:master</span>]) <span class="ruby-operator">?</span> <span class="ruby-identifier">first_source</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">qualifier_from_alias_symbol</span>(<span class="ruby-identifier">ta</span>, <span class="ruby-identifier">first_source</span>), <span class="ruby-value">:callback</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">callback</span>, <span class="ruby-value">:join_type</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">join_type</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">local_opts</span>[<span class="ruby-value">:join_type</span>], <span class="ruby-value">:join_only</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">local_opts</span>[<span class="ruby-value">:join_only</span>], <span class="ruby-value">:limit_strategy</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">limit_strategy</span>, <span class="ruby-value">:from_self_alias</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>][<span class="ruby-value">:master</span>])
<span class="line-num">3363</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>[<span class="ruby-value">:order_eager_graph</span>] <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">order</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:graph_order</span>, <span class="ruby-identifier">r</span>[<span class="ruby-value">:order</span>]))
<span class="line-num">3364</span>     <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">order_append</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">qualified_expression</span>(<span class="ruby-identifier">order</span>, <span class="ruby-identifier">assoc_table_alias</span>))
<span class="line-num">3365</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3366</span>   <span class="ruby-identifier">eager_graph</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:eager_graph</span>]
<span class="line-num">3367</span>   <span class="ruby-identifier">eager_graph</span>[<span class="ruby-value">:requirements</span>][<span class="ruby-identifier">assoc_table_alias</span>] = <span class="ruby-identifier">requirements</span>.<span class="ruby-identifier">dup</span>
<span class="line-num">3368</span>   <span class="ruby-identifier">eager_graph</span>[<span class="ruby-value">:reflections</span>][<span class="ruby-identifier">assoc_table_alias</span>] = <span class="ruby-identifier">r</span>
<span class="line-num">3369</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">limit_strategy</span> <span class="ruby-operator">==</span> <span class="ruby-value">:ruby</span>
<span class="line-num">3370</span>     <span class="ruby-identifier">eager_graph</span>[<span class="ruby-value">:limits</span>][<span class="ruby-identifier">assoc_table_alias</span>] = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">limit_and_offset</span> 
<span class="line-num">3371</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3372</span>   <span class="ruby-identifier">eager_graph</span>[<span class="ruby-value">:cartesian_product_number</span>] <span class="ruby-operator">+=</span> <span class="ruby-identifier">r</span>[<span class="ruby-value">:cartesian_product_number</span>] <span class="ruby-operator">||</span> <span class="ruby-value">2</span>
<span class="line-num">3373</span>   <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph_associations</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">r</span>.<span class="ruby-identifier">associated_class</span>, <span class="ruby-identifier">assoc_table_alias</span>, <span class="ruby-identifier">requirements</span> <span class="ruby-operator">+</span> [<span class="ruby-identifier">assoc_table_alias</span>], <span class="ruby-operator">*</span><span class="ruby-identifier">associations</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">empty?</span>
<span class="line-num">3374</span>   <span class="ruby-identifier">ds</span>
<span class="line-num">3375</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eager_graph_associations" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">eager_graph_associations</span><span
            class="method-args">(ds, model, ta, requirements, *associations)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Check the associations are valid for the given model. Call <a href="DatasetMethods.html#method-i-eager_graph_association"><code>eager_graph_association</code></a> on each association.</p>

<p>Arguments:</p>
<dl class="rdoc-list note-list"><dt>ds 
<dd>
<p>Current dataset</p>
</dd><dt>model 
<dd>
<p>Current <a href="../../Model.html"><code>Model</code></a></p>
</dd><dt>ta 
<dd>
<p>table_alias used for the parent association</p>
</dd><dt>requirements 
<dd>
<p>an array, used as a stack for requirements</p>
</dd><dt>*associations 
<dd>
<p>the associations to add to the graph</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="eager_graph_associations-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">3386</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eager_graph_associations</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ta</span>, <span class="ruby-identifier">requirements</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">associations</span>)
<span class="line-num">3387</span>   <span class="ruby-identifier">associations</span>.<span class="ruby-identifier">flatten</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">association</span><span class="ruby-operator">|</span>
<span class="line-num">3388</span>     <span class="ruby-identifier">ds</span> = <span class="ruby-keyword">case</span> <span class="ruby-identifier">association</span>
<span class="line-num">3389</span>     <span class="ruby-keyword">when</span> <span class="ruby-constant">Symbol</span>, <span class="ruby-constant">SQL</span><span class="ruby-operator">::</span><span class="ruby-constant">AliasedExpression</span>
<span class="line-num">3390</span>       <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph_association</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ta</span>, <span class="ruby-identifier">requirements</span>, <span class="ruby-identifier">eager_graph_check_association</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">association</span>))
<span class="line-num">3391</span>     <span class="ruby-keyword">when</span> <span class="ruby-constant">Hash</span>
<span class="line-num">3392</span>       <span class="ruby-identifier">association</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">assoc</span>, <span class="ruby-identifier">assoc_assocs</span><span class="ruby-operator">|</span>
<span class="line-num">3393</span>         <span class="ruby-identifier">ds</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">eager_graph_association</span>(<span class="ruby-identifier">ds</span>, <span class="ruby-identifier">model</span>, <span class="ruby-identifier">ta</span>, <span class="ruby-identifier">requirements</span>, <span class="ruby-identifier">eager_graph_check_association</span>(<span class="ruby-identifier">model</span>, <span class="ruby-identifier">assoc</span>), <span class="ruby-identifier">assoc_assocs</span>)
<span class="line-num">3394</span>       <span class="ruby-keyword">end</span>
<span class="line-num">3395</span>       <span class="ruby-identifier">ds</span>
<span class="line-num">3396</span>     <span class="ruby-keyword">else</span>
<span class="line-num">3397</span>       <span class="ruby-identifier">raise</span>(<span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Error</span>, <span class="ruby-string">&#39;Associations must be in the form of a symbol or hash&#39;</span>)
<span class="line-num">3398</span>     <span class="ruby-keyword">end</span>
<span class="line-num">3399</span>   <span class="ruby-keyword">end</span>
<span class="line-num">3400</span>   <span class="ruby-identifier">ds</span>
<span class="line-num">3401</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-eager_graph_build_associations" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">eager_graph_build_associations</span><span
            class="method-args">(hashes)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Replace the array of plain hashes with an array of model objects will all eager_graphed associations set in the associations cache for each object.</p>
          
          

          
          <div class="method-source-code" id="eager_graph_build_associations-source">
            <pre>     <span class="ruby-comment"># File lib/sequel/model/associations.rb</span>
<span class="line-num">3405</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">eager_graph_build_associations</span>(<span class="ruby-identifier">hashes</span>)
<span class="line-num">3406</span>   <span class="ruby-identifier">hashes</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">_eager_graph_build_associations</span>(<span class="ruby-identifier">hashes</span>, <span class="ruby-identifier">eager_graph_loader</span>))
<span class="line-num">3407</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.1.2.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

