<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>module Sequel - Sequel: The Database Toolkit for Ruby</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="module">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
    
    <div id="extends-section" class="nav-section">
  <h3>Extended With Modules</h3>

  <ul class="link-list">
    
  
    <li><a class="extend" href="Sequel/DateParseInputHandler.html">Sequel::DateParseInputHandler</a>
  
  
  
    <li><a class="extend" href="Sequel/EvalInspect.html">Sequel::EvalInspect</a>
  
  
  
    <li><a class="extend" href="Sequel/FiberConcurrency.html">Sequel::FiberConcurrency</a>
  
  
  
    <li><a class="extend" href="Sequel/NamedTimezones.html">Sequel::NamedTimezones</a>
  
  
  
    <li><a class="extend" href="Sequel/ThreadLocalTimezones.html">Sequel::ThreadLocalTimezones</a>
  
  
  </ul>
</div>

    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-core_extensions-3F">::core_extensions?</a>
    
    <li ><a href="#method-c-migration">::migration</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="module-Sequel">
  <h1 id="module-Sequel" class="module">
    module Sequel
  </h1>

  <section class="description">
    
<p>The date_parse_input_handler extension allows for configuring how input to date parsing methods should be handled.  By default, the extension does not change behavior.  However, you can use the <code>Sequel.date_parse_input_handler</code> method to support custom handling of input strings to the date parsing methods.  For example, if you want to implement a length check to prevent denial of service vulnerabilities in older versions of Ruby, you can do:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">extension</span> <span class="ruby-value">:date_parse_input_handler</span>
<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">date_parse_input_handler</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">string</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">InvalidValue</span>, <span class="ruby-string">&quot;string length (200) exceeds the limit 128&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">string</span>.<span class="ruby-identifier">bytesize</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">128</span>
  <span class="ruby-identifier">string</span>
<span class="ruby-keyword">end</span>
</pre>

<p>You can also use <code>Sequel.date_parse_input_handler</code> to modify the string that will be passed to the parsing methods.  For example, you could truncate it:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">date_parse_input_handler</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">string</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">string</span>.<span class="ruby-identifier">b</span>[<span class="ruby-value">0</span>, <span class="ruby-value">128</span>]
<span class="ruby-keyword">end</span>
</pre>

<p>Be aware that modern versions of Ruby will raise an exception if date parsing input exceeds 128 bytes.</p>

<p>The duplicate_columns_handler extension allows you to customize handling of duplicate column names in your queries on a per-database or per-dataset level.</p>

<p>For example, you may want to raise an exception if you join 2 tables together which contains a column that will override another columns.</p>

<p>To use the extension, you need to load the extension into the database:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">extension</span> <span class="ruby-value">:duplicate_columns_handler</span>
</pre>

<p>or into individual datasets:</p>

<pre class="ruby"><span class="ruby-identifier">ds</span> = <span class="ruby-constant">DB</span>[<span class="ruby-value">:items</span>].<span class="ruby-identifier">extension</span>(<span class="ruby-value">:duplicate_columns_handler</span>)
</pre>

<p>A database option is introduced: :on_duplicate_columns. It accepts a <a href="Symbol.html"><code>Symbol</code></a> or any object that responds to :call.</p>

<pre>on_duplicate_columns: :raise
on_duplicate_columns: :warn
on_duplicate_columns: :ignore
on_duplicate_columns: lambda{|columns| arbitrary_condition? ? :raise : :warn}</pre>

<p>You may also configure duplicate columns handling for a specific dataset:</p>

<pre class="ruby"><span class="ruby-identifier">ds</span>.<span class="ruby-identifier">on_duplicate_columns</span>(<span class="ruby-value">:warn</span>)
<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">on_duplicate_columns</span>(<span class="ruby-value">:raise</span>)
<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">on_duplicate_columns</span>(<span class="ruby-value">:ignore</span>)
<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">on_duplicate_columns</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">columns</span><span class="ruby-operator">|</span> <span class="ruby-identifier">arbitrary_condition?</span> <span class="ruby-operator">?</span> <span class="ruby-value">:raise</span> <span class="ruby-operator">:</span> <span class="ruby-value">:warn</span>}
<span class="ruby-identifier">ds</span>.<span class="ruby-identifier">on_duplicate_columns</span>(<span class="ruby-identifier">lambda</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">columns</span><span class="ruby-operator">|</span> <span class="ruby-identifier">arbitrary_condition?</span> <span class="ruby-operator">?</span> <span class="ruby-value">:raise</span> <span class="ruby-operator">:</span> <span class="ruby-value">:warn</span>})
</pre>

<p>If :raise is specified, a <a href="Sequel/DuplicateColumnError.html"><code>Sequel::DuplicateColumnError</code></a> is raised. If :warn is specified, you will receive a warning via <code>warn</code>. If a callable is specified, it will be called. If no on_duplicate_columns is specified, the default is :warn.</p>

<p>Related module: <a href="Sequel/DuplicateColumnsHandler.html"><code>Sequel::DuplicateColumnsHandler</code></a></p>

<p>:nocov:</p>

<p>The pg_range extension adds support for the PostgreSQL 9.2+ range types to <a href="Sequel.html"><code>Sequel</code></a>.  PostgreSQL range types are similar to ruby&#39;s <a href="Range.html"><code>Range</code></a> class, representating an array of values.  However, they are more flexible than ruby&#39;s ranges, allowing exclusive beginnings and endings (ruby&#39;s range only allows exclusive endings).</p>

<p>When PostgreSQL range values are retreived, they are parsed and returned as instances of <a href="Sequel/Postgres/PGRange.html"><code>Sequel::Postgres::PGRange</code></a>.  PGRange mostly acts like a <a href="Range.html"><code>Range</code></a>, but it&#39;s not a <a href="Range.html"><code>Range</code></a> as not all PostgreSQL range type values would be valid ruby ranges.  If the range type value you are using is a valid ruby range, you can call PGRange#to_range to get a <a href="Range.html"><code>Range</code></a>.  However, if you call PGRange#to_range on a range type value uses features that ruby&#39;s <a href="Range.html"><code>Range</code></a> does not support, an exception will be raised.</p>

<p>In addition to the parser, this extension comes with literalizers for PGRange and <a href="Range.html"><code>Range</code></a>, so they can be used in queries and as bound variables.</p>

<p>To turn an existing <a href="Range.html"><code>Range</code></a> into a PGRange, use Sequel.pg_range:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">pg_range</span>(<span class="ruby-identifier">range</span>)
</pre>

<p>If you have loaded the <a href="doc/core_extensions_rdoc.html">core_extensions extension</a>, or you have loaded the core_refinements extension and have activated refinements for the file, you can also use <a href="Range.html#method-i-pg_range"><code>Range#pg_range</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">range</span>.<span class="ruby-identifier">pg_range</span>
</pre>

<p>You may want to specify a specific range type:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">pg_range</span>(<span class="ruby-identifier">range</span>, <span class="ruby-value">:daterange</span>)
<span class="ruby-identifier">range</span>.<span class="ruby-identifier">pg_range</span>(<span class="ruby-value">:daterange</span>)
</pre>

<p>If you specify the range database type, <a href="Sequel.html"><code>Sequel</code></a> will automatically cast the value to that type when literalizing.</p>

<p>To use this extension, load it into the <a href="Database.html"><code>Database</code></a> instance:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">extension</span> <span class="ruby-value">:pg_range</span>
</pre>

<p>See the schema modification guide for details on using range type columns in CREATE/ALTER TABLE statements.</p>

<p>This extension makes it easy to add support for other range types.  In general, you just need to make sure that the subtype is handled and has the appropriate converter installed.  For user defined types, you can do this via:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">add_conversion_proc</span>(<span class="ruby-identifier">subtype_oid</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">string</span><span class="ruby-operator">|</span> }
</pre>

<p>Then you can call <a href="Sequel/Postgres/PGRange/DatabaseMethods.html#method-i-register_range_type"><code>Sequel::Postgres::PGRange::DatabaseMethods#register_range_type</code></a> to automatically set up a handler for the range type.  So if you want to support the timerange type (assuming the time type is already supported):</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">register_range_type</span>(<span class="ruby-string">&#39;timerange&#39;</span>)
</pre>

<p>This extension integrates with the pg_array extension.  If you plan to use arrays of range types, load the pg_array extension before the pg_range extension:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">extension</span> <span class="ruby-value">:pg_array</span>, <span class="ruby-value">:pg_range</span>
</pre>

<p>Related module: <a href="Sequel/Postgres/PGRange.html"><code>Sequel::Postgres::PGRange</code></a></p>

<p>The round_timestamps extension will automatically round timestamp values to the database&#39;s supported level of precision before literalizing them.</p>

<p>For example, if the database supports millisecond precision, and you give it a Time value with microsecond precision, it will round it appropriately:</p>

<pre class="ruby"><span class="ruby-constant">Time</span>.<span class="ruby-identifier">at</span>(<span class="ruby-value">1405341161.917999982833862</span>)
<span class="ruby-comment"># default: 2014-07-14 14:32:41.917999</span>
<span class="ruby-comment"># with extension: 2014-07-14 14:32:41.918000</span>
</pre>

<p>The round_timestamps extension correctly deals with databases that support millisecond or second precision.  In addition to handling Time values, it also handles DateTime values and Sequel::SQLTime values (for the TIME type).</p>

<p>To round timestamps for a single dataset:</p>

<pre class="ruby"><span class="ruby-identifier">ds</span> = <span class="ruby-identifier">ds</span>.<span class="ruby-identifier">extension</span>(<span class="ruby-value">:round_timestamps</span>)
</pre>

<p>To round timestamps for all datasets on a single database:</p>

<pre class="ruby"><span class="ruby-constant">DB</span>.<span class="ruby-identifier">extension</span>(<span class="ruby-value">:round_timestamps</span>)
</pre>

<p>Related module: <a href="Sequel/Dataset/RoundTimestamps.html"><code>Sequel::Dataset::RoundTimestamps</code></a></p>

  </section>

  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-core_extensions-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">core_extensions?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This extension loads the core extensions.</p>
          
          

          
          <div class="method-source-code" id="core_extensions-3F-source">
            <pre>   <span class="ruby-comment"># File lib/sequel/extensions/core_extensions.rb</span>
<span class="line-num">11</span> <span class="ruby-keyword">def</span> <span class="ruby-constant">Sequel</span>.<span class="ruby-identifier ruby-title">core_extensions?</span>
<span class="line-num">12</span>   <span class="ruby-keyword">true</span>
<span class="line-num">13</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-migration" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">migration</span><span
            class="method-args">(&amp;block)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The preferred method for writing <a href="Sequel.html"><code>Sequel</code></a> migrations, using a DSL:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">migration</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">up</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">create_table</span>(<span class="ruby-value">:artists</span>) <span class="ruby-keyword">do</span>
      <span class="ruby-identifier">primary_key</span> <span class="ruby-value">:id</span>
      <span class="ruby-constant">String</span> <span class="ruby-value">:name</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">down</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">drop_table</span>(<span class="ruby-value">:artists</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Designed to be used with the <code>Migrator</code> class, part of the <code>migration</code> extension.</p>
          
          

          
          <div class="method-source-code" id="migration-source">
            <pre>    <span class="ruby-comment"># File lib/sequel/extensions/migration.rb</span>
<span class="line-num">291</span> <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">migration</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
<span class="line-num">292</span>   <span class="ruby-constant">MigrationDSL</span>.<span class="ruby-identifier">create</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
<span class="line-num">293</span> <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.1.2.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

